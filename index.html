<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Rhythm 8 - No Health Final</title>
    <!-- JSZip for Zip I/O -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --primary: #0ff;
            --secondary: #f0f;
            --bg: #000;
            --panel-bg: rgba(10, 20, 30, 0.95);
            --ap-color: #ffd700;
            --fc-color: #00bfff;
            --norm-color: #fff;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0; background-color: var(--bg); overflow: hidden;
            font-family: 'Orbitron', sans-serif; touch-action: none;
            user-select: none; -webkit-user-select: none; color: #fff;
            width: 100vw; height: 100vh;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI Base */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            pointer-events: auto; backdrop-filter: blur(5px);
            padding: 2vmin;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }

        h1 { color: #fff; text-shadow: 0 0 10px var(--primary); font-size: 6vmin; margin: 0; line-height: 1; text-align: center; }
        .sub-title { color: var(--secondary); font-size: 2.5vmin; margin-bottom: 2vmin; text-align: center; }

        .btn {
            background: rgba(0, 255, 255, 0.1); color: var(--primary); border: 2px solid var(--primary);
            padding: 1.5vmin 3vmin; font-size: 2.5vmin; font-family: 'Orbitron', sans-serif;
            cursor: pointer; margin: 0.5vmin; transition: 0.2s; border-radius: 8px; text-transform: uppercase;
            min-width: 12vmin; text-align: center; display: inline-block;
        }
        .btn:active { background: var(--primary); color: #000; transform: scale(0.95); }
        .btn-secondary { border-color: #666; color: #aaa; }
        .btn-danger { border-color: #f00; color: #f55; }
        .btn-record { border-color: #f00; color: #fff; background: rgba(255,0,0,0.2); }
        .btn-record.recording { background: #f00; box-shadow: 0 0 30px #f00; animation: pulse 1s infinite; }
        .btn-sm { padding: 1vmin 2vmin; font-size: 2.5vmin; min-width: auto; }
        /* Active state for toggle buttons */
        .btn.active { background: var(--primary); color: #000; box-shadow: 0 0 15px var(--primary); }

        /* Split Layout */
        .split-container {
            display: flex; flex-direction: row; width: 95vw; height: 50vh; gap: 2vmin; margin-bottom: 2vmin;
        }
        .list-column {
            flex: 1; display: flex; flex-direction: column;
            background: rgba(0, 20, 40, 0.5); border: 1px solid #333; border-radius: 1vmin;
            padding: 1vmin; overflow: hidden;
        }
        .column-header {
            font-size: 2.5vmin; color: var(--primary); border-bottom: 1px solid #444;
            padding-bottom: 1vmin; margin-bottom: 1vmin; text-align: center;
        }
        .scroll-list {
            flex: 1; overflow-y: auto; padding-right: 0.5vmin;
        }

        /* List Items & Marquee */
        .song-item {
            position: relative;
            padding: 1.5vmin; border-bottom: 1px solid #333; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            height: 6vmin; overflow: hidden;
        }
        .song-item:active { background: rgba(0, 255, 255, 0.2); }
        .song-item.selected { background: rgba(0, 255, 255, 0.2); border-left: 4px solid var(--primary); }
        
        .title-container {
            flex: 1; overflow: hidden; white-space: nowrap; position: relative; margin-right: 1vmin;
            mask-image: linear-gradient(to right, black 90%, transparent 100%);
        }
        .song-title {
            display: inline-block; font-size: 2.5vmin; font-weight: bold; color: #fff;
        }
        .marquee {
            animation: marquee-anim 8s linear infinite;
            padding-right: 5vmin;
        }
        @keyframes marquee-anim {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        .song-meta { font-size: 2vmin; color: #888; flex-shrink: 0; }
        .item-actions { display: flex; gap: 1vmin; }

        /* File Input */
        .file-label {
            display: block; position: relative; overflow: hidden;
            background: rgba(255, 255, 255, 0.05); border: 1px dashed #666;
            padding: 1.5vmin; border-radius: 4px; text-align: center;
            cursor: pointer; color: #aaa; font-size: 2vmin; margin-top: 1vmin;
        }
        .file-label:hover { background: rgba(255, 255, 255, 0.1); border-color: #fff; }
        .file-label input[type="file"] { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

        /* Rotate Message */
        #rotate-message {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: var(--primary); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999; text-align: center;
        }
        #rotate-message svg { width: 15vmin; height: 15vmin; fill: var(--primary); animation: rotate-anim 2s infinite; }
        @keyframes rotate-anim { 0% { transform: rotate(0deg); } 25% { transform: rotate(-90deg); } 100% { transform: rotate(-90deg); } }

        /* Countdown */
        #countdown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); z-index: 300; display: none;
            align-items: center; justify-content: center; 
            pointer-events: auto; /* Blocks interaction */
        }
        #countdown-text {
            font-size: 30vmin; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px var(--primary);
            opacity: 0; 
        }
        .count-anim { animation: count-pop 0.9s ease-out forwards; }
        @keyframes count-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        .go-anim { animation: go-pop 0.5s ease-out forwards; }
        @keyframes go-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1.2); opacity: 1; }
        }

        /* HUD */
        .hud-top {
            padding: 1vmin 2vmin; display: flex; justify-content: space-between; align-items: flex-start;
            width: 100%; box-sizing: border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            height: 18vh; pointer-events: auto;
        }
        .score-val { font-size: 6vmin; color: var(--primary); font-weight: bold; }
        .progress-bar-bg { width: 30vw; height: 1.5vmin; background: #333; border-radius: 1vmin; margin-top: 0.5vmin; }
        .progress-bar-fill { height: 100%; background: var(--secondary); width: 0%; border-radius: 1vmin; }
        
        .editor-controls { display: flex; gap: 2vmin; pointer-events: auto; }

        .combo-box { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
        
        .combo-val { font-size: 12vmin; font-weight: bold; text-shadow: 0 0 2vmin rgba(255,255,255,0.2); transition: color 0.2s; }
        .combo-ap { color: var(--ap-color); text-shadow: 0 0 3vmin rgba(255, 215, 0, 0.6); }
        .combo-fc { color: var(--fc-color); text-shadow: 0 0 3vmin rgba(0, 191, 255, 0.6); }
        .combo-norm { color: var(--norm-color); text-shadow: 0 0 2vmin rgba(255,0,255,0.3); }

        .judgement-text {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-size: 10vmin; font-weight: 900; opacity: 0; pointer-events: none; z-index: 20;
            text-shadow: 0 0 10px #000;
        }

        /* Settings Panel */
        .settings-panel {
            background: var(--panel-bg); padding: 4vmin; border: 1px solid var(--primary);
            border-radius: 2vmin; width: 85vw; max-width: 600px;
            display: flex; flex-direction: column; align-items: center; gap: 2vmin;
        }
        .setting-item { margin-bottom: 2vmin; width: 100%; }
        .setting-label { display: flex; justify-content: space-between; color: #ccc; font-size: 3.5vmin; font-family: 'Roboto Mono'; }
        input[type=range] { width: 100%; height: 6vmin; }
        
        /* Touch Zones */
        #touch-zones { position: absolute; bottom: 0; width: 100%; height: 25vh; display: flex; pointer-events: none; z-index: 5; }
        .zone {
            flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: flex-end;
            justify-content: center; padding-bottom: 2vmin; color: rgba(255,255,255,0.3); font-size: 3vmin; font-weight: bold;
        }

        #rec-instruction {
            position: absolute; bottom: 25vh; width: 100%; text-align: center;
            font-size: 3vmin; color: #ff0; text-shadow: 0 0 5px #000;
            pointer-events: none; display: none;
        }

        #global-settings-btn {
            position: absolute;
            bottom: 3vmin;
            right: 3vmin;
            margin: 0;
            z-index: 150;
            padding: 1.5vmin 3vmin;
            font-size: 2.5vmin;
        }

        /* Detail Editor UI */
        #detail-editor-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column; justify-content: space-between;
            z-index: 50;
        }
        .de-top-bar {
            background: rgba(0,0,0,0.8); width: 100%; padding: 1vmin;
            display: flex; justify-content: space-between; align-items: center; pointer-events: auto;
            border-bottom: 1px solid #333;
        }
        .de-bottom-bar {
            background: rgba(0,10,20,0.95); width: 100%; padding: 1vmin;
            display: flex; flex-direction: column; gap: 1vmin; pointer-events: auto;
            border-top: 1px solid var(--primary);
        }
        .de-row { display: flex; gap: 2vmin; align-items: center; width: 100%; }
        .de-label { font-size: 2vmin; color: #aaa; white-space: nowrap; }
        .de-tools { display: flex; gap: 1vmin; overflow-x: auto; padding-bottom: 0.5vmin; align-items: center; }
        
        .de-time-display { font-family: 'Roboto Mono'; color: var(--primary); font-size: 3vmin; min-width: 15vmin; text-align: center; }
        
        /* Custom range slider for editor */
        input[type=range].editor-slider {
            -webkit-appearance: none; background: #333; height: 1vmin; border-radius: 0.5vmin;
        }
        input[type=range].editor-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 3vmin; height: 3vmin; background: var(--primary); border-radius: 50%; cursor: pointer;
        }
        
        /* Test Stop Button */
        #test-stop-btn {
            position: fixed; top: 2vmin; right: 2vmin; z-index: 200;
            display: none; padding: 1vmin 3vmin; font-size: 3vmin;
            background: rgba(255, 0, 0, 0.8); color: #fff;
            border: 2px solid #fff; border-radius: 8px;
            font-weight: bold; pointer-events: auto;
        }

        @media (orientation: portrait) { #rotate-message { display: flex; } }
    </style>
</head>
<body>

    <div id="rotate-message">
        <svg viewBox="0 0 24 24"><path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/></svg>
        <p>ROTATE DEVICE</p>
    </div>

    <div id="countdown-overlay"><div id="countdown-text"></div></div>
    
    <!-- Test Play Stop Button -->
    <button id="test-stop-btn">STOP TEST</button>
    
    <canvas id="gameCanvas"></canvas>

    <!-- Detail Editor UI Overlay -->
    <div id="detail-editor-ui">
        <div class="de-top-bar">
            <div style="display:flex; gap:1vmin;">
                <button class="btn btn-sm" id="de-exit-btn">EXIT</button>
                <button class="btn btn-danger btn-sm" id="de-save-btn">SAVE</button>
                <button class="btn btn-secondary btn-sm" id="de-zip-btn">ZIP</button>
                <div class="de-time-display" id="de-time">00:00.000</div>
            </div>
            <div style="display:flex; gap:1vmin; align-items:center;">
                <span class="de-label">ZOOM</span>
                <input type="range" class="editor-slider" id="de-zoom" min="0.5" max="3.0" step="0.1" value="1.0" style="width:15vmin;">
                <button class="btn btn-sm" id="de-test-btn">â–¶ TEST</button>
            </div>
        </div>
        
        <div class="de-bottom-bar">
            <!-- Seekbar -->
            <div class="de-row">
                <span class="de-label">SEEK</span>
                <input type="range" class="editor-slider" id="de-seek" min="0" max="100" step="0.01" value="0" style="flex:1;">
            </div>
            <!-- Tools -->
            <div class="de-row" style="justify-content: space-between;">
                <div class="de-tools">
                    <button class="btn btn-sm active" id="tool-select">SELECT</button>
                    <button class="btn btn-sm" id="tool-tap">TAP</button>
                    <button class="btn btn-sm" id="tool-flick">FLICK</button>
                    <button class="btn btn-sm" id="tool-hold">HOLD</button>
                    <button class="btn btn-danger btn-sm" id="tool-del">DEL</button>
                </div>
                <div class="de-tools" id="de-modify-controls" style="visibility: hidden; gap:0.5vmin;">
                    <span class="de-label" style="font-size:1.5vmin;">TIME</span>
                    <button class="btn btn-secondary btn-sm" id="mod-minus">-</button>
                    <button class="btn btn-secondary btn-sm" id="mod-plus">+</button>
                    
                    <div id="de-len-controls" style="display:none; gap:0.5vmin; align-items:center; border-left:1px solid #555; padding-left:0.5vmin; margin-left:0.5vmin;">
                        <span class="de-label" style="font-size:1.5vmin;">LEN</span>
                        <button class="btn btn-secondary btn-sm" id="mod-len-minus">-</button>
                        <button class="btn btn-secondary btn-sm" id="mod-len-plus">+</button>
                    </div>
                </div>
                <div class="de-tools">
                    <span class="de-label">SNAP</span>
                    <button class="btn btn-sm" id="tool-snap">1/4</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Song Selection Screen -->
    <div id="song-select-screen" class="screen">
        <h1>CYBER RHYTHM</h1>
        <div class="sub-title">SELECT TRACK & CHART</div>
        
        <div class="split-container">
            <div class="list-column">
                <div class="column-header">AUDIO TRACKS</div>
                <div id="audio-list" class="scroll-list"></div>
                <label class="file-label">
                    ðŸŽµ ADD AUDIO (mp3/wav)
                    <input type="file" id="audio-upload" accept=".mp3, .wav, audio/mpeg, audio/wav, audio/mp3, audio/*">
                </label>
            </div>

            <div class="list-column">
                <div class="column-header">CHARTS LIBRARY</div>
                <div id="chart-list" class="scroll-list"></div>
                <label class="file-label">
                    ðŸ“‚ IMPORT CHART (.json)
                    <input type="file" id="chart-upload" accept=".json, application/json">
                </label>
            </div>
        </div>

        <div style="display:flex; gap:2vmin; width: 100%; justify-content: center; margin-bottom: 2vmin;">
            <label class="btn btn-secondary" style="font-size:2vmin; padding: 1vmin 2vmin;">
                ðŸ“¦ IMPORT ZIP
                <input type="file" id="zip-upload" accept=".zip, application/zip" style="display:none;">
            </label>
        </div>

        <div style="display:flex; gap:2vmin; width: 100%; justify-content: center;">
            <button class="btn" id="play-song-btn">PLAY</button>
            <button class="btn btn-secondary" id="editor-btn">EDITOR</button>
        </div>
        
        <button class="btn btn-secondary" id="global-settings-btn">SETTINGS</button>
    </div>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-top" id="hud" style="display:none;">
            <div><div style="font-size: 2.5vmin; color:#aaa;">SCORE</div><div class="score-val" id="score">0</div></div>
            <div style="display:flex; flex-direction:column; align-items:center; flex:1; margin:0 2vmin;">
                <div style="font-size: 2.5vmin; color:#aaa;">TIME</div>
                <div class="progress-bar-bg"><div class="progress-bar-fill" id="time-bar"></div></div>
            </div>
            
            <div id="play-controls" style="display:flex; align-items:flex-start;">
                <!-- HP Removed -->
                <button class="btn btn-sm" id="pause-btn">II</button>
            </div>

            <div id="editor-controls" class="editor-controls" style="display:none;">
                <button class="btn btn-record btn-sm" id="rec-btn">REC</button>
                <button class="btn btn-sm" id="detail-btn">DETAIL</button> <!-- NEW -->
                <button class="btn btn-sm" id="editor-pause-btn" style="display:none;">II</button>
            </div>
        </div>
        <div class="combo-box" id="combo-box">
            <div class="combo-val" id="combo-val"></div>
            <div id="combo-label" style="font-size:3vmin; color:#fff; opacity:0;">COMBO</div>
        </div>
        <div id="judgement" class="judgement-text"></div>
        <div id="rec-instruction">TAP=Hit | SWIPE=Flick | HOLD=Long (>0.6s)</div>
        <div id="touch-zones"></div>
    </div>

    <!-- Pause Screens -->
    <div id="pause-screen" class="screen" style="display:none;">
        <div class="settings-panel">
            <h2 style="color:#fff;">PAUSED</h2>
            <button class="btn" id="resume-btn">RESUME</button>
            <button class="btn btn-secondary" id="retry-btn">RESTART</button>
            <button class="btn btn-danger" id="quit-btn">EXIT</button>
        </div>
    </div>

    <div id="editor-menu-screen" class="screen" style="display:none;">
        <div class="settings-panel">
            <h2 style="color:#fff;">EDITOR MENU</h2>
            <button class="btn" id="editor-resume-btn">RESUME</button>
            <button class="btn btn-secondary" id="editor-zip-btn">ðŸ“¦ EXPORT ZIP</button>
            <button class="btn btn-secondary" id="editor-reset-btn">RESET</button>
            <button class="btn btn-danger" id="editor-save-btn">SAVE & QUIT</button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings-screen" class="screen" style="display:none;">
        <div class="settings-panel">
            <h2 style="color:#fff;">CONFIG</h2>
            <div class="setting-item">
                <div class="setting-label"><span>SPEED</span><span id="val-speed">400</span></div>
                <input type="range" id="input-speed" min="200" max="1200" step="50" value="400">
            </div>
            <div class="setting-item">
                <div class="setting-label"><span>OFFSET (ms)</span><span id="val-offset">0</span></div>
                <input type="range" id="input-offset" min="-200" max="200" step="10" value="0">
            </div>
            <div class="setting-item">
                <div class="setting-label"><span>VOLUME</span><span id="val-volume">80%</span></div>
                <input type="range" id="input-volume" min="0" max="100" step="5" value="80">
            </div>
            <button class="btn" id="settings-close-btn">OK</button>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="screen" style="display:none;">
        <h1 id="result-title">FINISH</h1>
        <div style="font-size:12vmin; font-weight:bold; color:var(--primary); margin:2vmin 0;" id="final-rank">A</div>
        <div style="width:80%; font-family:'Roboto Mono'; color:#ccc; font-size:3.5vmin; display:grid; grid-template-columns:1fr 1fr; gap:2vmin; text-align:left;">
            <div>SCORE</div><div id="final-score" style="text-align:right; color:#fff;">0</div>
            <div>COMBO</div><div id="final-combo" style="text-align:right; color:#fff;">0</div>
        </div>
        <div style="margin-top:4vmin; display:flex; gap:2vmin;">
            <button class="btn" id="res-retry-btn">RETRY</button>
            <button class="btn btn-secondary" id="res-quit-btn">TITLE</button>
        </div>
    </div>

<script>
/** GLOBAL SETTINGS */
const Settings = {
    speed: 500, offset: 0, volume: 0.8,
    load() { try { const d = JSON.parse(localStorage.getItem('cb8_mobile_settings')); if(d) Object.assign(this, d); } catch(e){} this.updateUI(); },
    save() { localStorage.setItem('cb8_mobile_settings', JSON.stringify(this)); },
    updateUI() {
        document.getElementById('input-speed').value = this.speed; document.getElementById('val-speed').innerText = this.speed;
        document.getElementById('input-offset').value = this.offset * 1000; document.getElementById('val-offset').innerText = (this.offset * 1000);
        document.getElementById('input-volume').value = this.volume * 100; document.getElementById('val-volume').innerText = Math.round(this.volume * 100) + '%';
    }
};
document.getElementById('input-speed').addEventListener('input', e => { Settings.speed = +e.target.value; document.getElementById('val-speed').innerText = Settings.speed; });
document.getElementById('input-offset').addEventListener('input', e => { Settings.offset = +e.target.value / 1000; document.getElementById('val-offset').innerText = e.target.value; });
document.getElementById('input-volume').addEventListener('input', e => { Settings.volume = +e.target.value / 100; document.getElementById('val-volume').innerText = e.target.value + '%'; if(audio) audio.setVolume(Settings.volume); });

/** AUDIO ENGINE */
class AudioEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        this.bpm = 145; this.beatCount = 0; this.nextNoteTime = 0; 
        this.scheduleAheadTime = 3.0; this.lookahead = 25.0;
        this.isPlaying = false; this.mode = 'SYNTH'; 
        this.bufferSource = null; this.audioBuffer = null;
        this.startTime = 0; 
        this.pausedAt = 0;
        this.onTick = null; 
        this.demoPattern = [[1,3,0,3, 2,3,0,3, 1,3,5,3, 2,3,4,3], [1,3,0,3, 2,3,4,3, 1,3,0,3, 2,5,4,4]].flat();
    }
    setVolume(v) { this.masterGain.gain.setValueAtTime(v, this.ctx.currentTime); }
    async loadAudio(file) {
        const arrayBuffer = await file.arrayBuffer();
        this.audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
        this.mode = 'BUFFER';
    }
    setUseSynth() { this.mode = 'SYNTH'; }
    getCurrentTime() {
        if (!this.isPlaying) return this.pausedAt;
        return this.ctx.currentTime - this.startTime;
    }
    getDuration() {
        if (this.mode === 'BUFFER' && this.audioBuffer) return this.audioBuffer.duration;
        return 120; // 2 min demo loop limit
    }
    async start(offset = 0) {
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        this.isPlaying = true;
        this.startTime = this.ctx.currentTime - offset;
        
        if (this.mode === 'BUFFER' && this.audioBuffer) {
            this.bufferSource = this.ctx.createBufferSource();
            this.bufferSource.buffer = this.audioBuffer;
            this.bufferSource.connect(this.masterGain);
            this.bufferSource.start(0, offset);
        } else {
            const secPerBeat = 60.0 / this.bpm / 4;
            this.beatCount = Math.floor(offset / secPerBeat);
            const nextBeatTime = (this.beatCount + 1) * secPerBeat;
            this.nextNoteTime = this.ctx.currentTime + (nextBeatTime - offset);
            this.scheduler();
        }
    }
    pause() {
        if(!this.isPlaying) return;
        this.pausedAt = this.ctx.currentTime - this.startTime;
        this.stop();
    }
    stop() {
        this.isPlaying = false;
        if (this.bufferSource) { try { this.bufferSource.stop(); } catch(e){} this.bufferSource = null; }
        clearTimeout(this.timerID);
    }
    scheduler() {
        if (!this.isPlaying || this.mode !== 'SYNTH') return;
        while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
            this.playSynthNote(this.beatCount, this.nextNoteTime);
            this.nextNoteTime += (60.0 / this.bpm / 4);
            this.beatCount++;
        }
        this.timerID = setTimeout(() => this.scheduler(), this.lookahead);
    }
    playSynthNote(beat, time) {
        if (this.onTick) this.onTick(beat, time); 
        const type = this.demoPattern[beat % this.demoPattern.length];
        if (type === 1) this.playTone(time, 150, 'sine', 0.5);
        if (type === 2) this.playNoise(time, 1000);
        if (type === 3) this.playNoise(time, 5000, 0.05);
        if (type === 4) this.playTone(time, 55, 'sawtooth', 0.4);
        if (type === 5) this.playTone(time, 45, 'square', 1.0);
    }
    playTone(time, freq, type, dur) {
        const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, time);
        if(type==='sine') osc.frequency.exponentialRampToValueAtTime(10, time + dur);
        g.gain.setValueAtTime(Settings.volume, time); g.gain.exponentialRampToValueAtTime(0.01, time + dur);
        osc.connect(g); g.connect(this.masterGain); osc.start(time); osc.stop(time + dur);
    }
    playNoise(time, freq, dur=0.2) {
        const b = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
        const d = b.getChannelData(0); for(let i=0; i<d.length; i++) d[i] = Math.random()*2-1;
        const src = this.ctx.createBufferSource(); src.buffer = b;
        const f = this.ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = freq;
        const g = this.ctx.createGain(); g.gain.setValueAtTime(Settings.volume*0.5, time); g.gain.exponentialRampToValueAtTime(0.01, time + dur);
        src.connect(f); f.connect(g); g.connect(this.masterGain); src.start(time); src.stop(time + dur);
    }
}

/** GAME & LIBRARY */
const audio = new AudioEngine();
Settings.load();

const SongLibrary = {
    songs: [{ id: 'demo', title: 'DEMO TRACK', type: 'SYNTH', chart: null, originalBlob: null }],
    selectedIdx: 0,
    selectedChartKey: null,
    savedCharts: [],

    init() {
        this.loadSavedCharts();
        this.renderList();
    },
    loadSavedCharts() {
        this.savedCharts = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('cb8_chart_')) {
                try {
                    const data = JSON.parse(localStorage.getItem(key));
                    this.savedCharts.push({ key: key, title: data.title, date: data.date });
                } catch(e) {}
            }
        }
    },
    addSong(title, buffer, originalBlob = null) { 
        this.songs.push({ id: Date.now(), title: title, type: 'BUFFER', buffer: buffer, chart: [], originalBlob: originalBlob }); 
        this.renderList(); 
    },
    // DELETE FUNCTION
    removeSong(idx) {
        if(idx === 0) return; // Prevent deleting demo
        if(!confirm("Delete this audio track?")) return;
        this.songs.splice(idx, 1);
        if(this.selectedIdx >= this.songs.length) this.selectedIdx = this.songs.length - 1;
        this.renderList();
    },
    removeSavedChart(index) {
        if(!confirm("Delete this saved chart?")) return;
        const chart = this.savedCharts[index];
        localStorage.removeItem(chart.key);
        this.savedCharts.splice(index, 1);
        if(this.selectedChartKey === chart.key) this.selectedChartKey = null;
        this.renderList();
    },
    
    setChart(idx, chartData) { if (this.songs[idx]) this.songs[idx].chart = chartData; },
    saveChartToStorage(chartData, title) {
        const key = 'cb8_chart_' + Date.now();
        const saveObj = { title: title || 'Untitled', date: new Date().toLocaleDateString(), data: chartData };
        localStorage.setItem(key, JSON.stringify(saveObj));
        this.loadSavedCharts(); this.renderList();
    },
    loadChartFromStorage(key) {
        const raw = localStorage.getItem(key); if(!raw) return null;
        return JSON.parse(raw).data;
    },
    exportSavedChart(key, title) {
        const raw = localStorage.getItem(key); if(!raw) return;
        const chartData = JSON.parse(raw).data;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(chartData));
        const a = document.createElement('a'); a.setAttribute("href", dataStr); a.setAttribute("download", (title || "chart") + ".json");
        document.body.appendChild(a); a.click(); a.remove();
    },
    exportZipPackage(idx) {
        const song = this.songs[idx];
        if(!song || !song.originalBlob) { alert("Cannot export ZIP: No audio file data available (Demo track or imported raw)."); return; }
        
        // Ensure current chart is saved to song object
        if (game.isEditor && game.state.includes('EDITOR')) game.saveCurrentChart();

        const zip = new JSZip();
        // Add chart
        const chartData = song.chart || [];
        zip.file("chart.json", JSON.stringify(chartData));
        
        // Add Audio
        let ext = "mp3";
        if (song.originalBlob.type === "audio/wav") ext = "wav";
        if (song.originalBlob.type === "audio/ogg") ext = "ogg";
        if (song.originalBlob.name) {
            const parts = song.originalBlob.name.split('.');
            if(parts.length > 1) ext = parts.pop();
        }
        zip.file(`audio.${ext}`, song.originalBlob);
        
        zip.generateAsync({type:"blob"}).then(function(content) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = (song.title || "project") + ".zip";
            document.body.appendChild(a); a.click(); a.remove();
        });
    },
    renderList() {
        const ac = document.getElementById('audio-list'); ac.innerHTML = '';
        this.songs.forEach((s, i) => {
            const div = document.createElement('div');
            div.className = `song-item ${i === this.selectedIdx ? 'selected' : ''}`;
            
            // Build inner HTML with delete button for non-demo songs
            let html = `<div class="title-container"><span class="song-title">${s.title}</span></div>`;
            html += `<div class="item-actions">`;
            html += `<span class="song-meta">${s.type}</span>`;
            if (i > 0) { // Not demo
                html += `<button class="btn btn-danger btn-sm" style="padding:0 1vmin; font-size:1.5vmin;" onclick="event.stopPropagation(); SongLibrary.removeSong(${i})">Ã—</button>`;
            }
            html += `</div>`;
            
            div.innerHTML = html;
            div.onclick = () => { 
                this.selectedIdx = i; 
                this.selectedChartKey = null;
                this.renderList(); 
            };
            ac.appendChild(div);
            const span = div.querySelector('.song-title');
            const cont = div.querySelector('.title-container');
            if(span.scrollWidth > cont.clientWidth) span.classList.add('marquee');
        });

        const cc = document.getElementById('chart-list'); cc.innerHTML = '';
        const emptyDiv = document.createElement('div');
        emptyDiv.className = `song-item ${this.selectedChartKey === 'empty' ? 'selected' : ''}`;
        emptyDiv.innerHTML = `<div class="title-container"><span class="song-title" style="color:#aaa;">âž• [NEW] EMPTY CHART</span></div>`;
        emptyDiv.onclick = () => {
            this.selectedChartKey = 'empty';
            this.setChart(this.selectedIdx, []);
            this.renderList();
        };
        cc.appendChild(emptyDiv);

        if(this.savedCharts.length > 0) {
            this.savedCharts.forEach((s, i) => {
                const div = document.createElement('div');
                div.className = `song-item ${this.selectedChartKey === s.key ? 'selected' : ''}`;
                
                let html = `<div class="title-container"><span class="song-title">ðŸ’¾ ${s.title}</span></div>`;
                html += `<div class="item-actions">`;
                html += `<button class="btn btn-secondary btn-sm" style="padding:0.5vmin 1vmin;" onclick="event.stopPropagation(); SongLibrary.exportSavedChart('${s.key}', '${s.title}')">DL</button>`;
                html += `<button class="btn btn-danger btn-sm" style="padding:0.5vmin 1vmin;" onclick="event.stopPropagation(); SongLibrary.removeSavedChart(${i})">Ã—</button>`;
                html += `</div>`;
                
                div.innerHTML = html;
                div.onclick = () => {
                    this.selectedChartKey = s.key;
                    const data = this.loadChartFromStorage(s.key);
                    if(data) { this.setChart(this.selectedIdx, data); }
                    this.renderList();
                };
                cc.appendChild(div);
                const span = div.querySelector('.song-title');
                const cont = div.querySelector('.title-container');
                if(span.scrollWidth > cont.clientWidth) span.classList.add('marquee');
            });
        }
    }
};

const game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: false }),
    state: 'MENU', score: 0, combo: 0, maxCombo: 0, 
    laneCount: 8, lanes: [], particles: [], stats: { p:0, g:0, m:0 }, activeLanes: new Map(),
    lastTime: 0, isEditor: false, isRecording: false, isCountingDown: false,
    isAP: true, isFC: true,
    
    // NEW: Detail Editor Properties
    editorTime: 0,
    editorZoom: 1.0,
    editorTool: 'SELECT', // SELECT, TAP, FLICK, HOLD, DEL
    editorSelectedNote: null,
    editorSnap: 0, // 0=Off, 0.25=16th, etc.
    editorLastPlayTime: 0,
    // Scroll Logic
    editorIsScrolling: false,
    editorScrollStartY: 0,
    editorScrollStartTime: 0,

    init() {
        this.resize(); window.addEventListener('resize', () => this.resize());
        this.setupInputs(); this.generateTouchZones();
        audio.onTick = (beat, time) => { if (this.state === 'PLAYING' && !this.isEditor && audio.mode === 'SYNTH') this.spawnSynthNote(beat, time); };
        SongLibrary.init();
        requestAnimationFrame((ts) => this.loop(ts));
    },
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
    generateTouchZones() {
        const c = document.getElementById('touch-zones'); c.innerHTML = '';
        const k = ['S','D','F','G','H','J','K','L'];
        for(let i=0; i<8; i++){ const d=document.createElement('div'); d.className='zone'; d.innerText=k[i]; c.appendChild(d); }
    },

    spawnSynthNote(beat, time) {
        const pat = audio.demoPattern;
        const typeCode = pat[beat % pat.length];
        if (typeCode === 0) return;
        let l = -1, type = 'TAP', dur = 0;
        if(typeCode===1) l=Math.random()>0.5?3:4;
        else if(typeCode===2) { l=[0,1,6,7][Math.floor(Math.random()*4)]; type='FLICK'; }
        else if(typeCode===3) l=Math.random()>0.3?(Math.random()>0.5?2:5):Math.floor(Math.random()*8);
        else if(typeCode===4) l=Math.floor(Math.random()*8);
        else if(typeCode===5) { l=Math.floor(Math.random()*8); type='HOLD'; dur=0.5; }
        if(l!==-1) this.lanes[l].push({ hitTime: time, type: type, duration: dur, hit: false, holding: false, visible: true });
    },
    loadChart(chartData) {
        this.lanes = Array(this.laneCount).fill().map(()=>[]);
        if (!chartData) return;
        chartData.forEach(note => {
            if(note.l >= 0 && note.l < 8) {
                this.lanes[note.l].push({ hitTime: note.t, type: note.k, duration: note.d || 0, hit: false, holding: false, visible: true });
            }
        });
        this.lanes.forEach(l => l.sort((a,b) => a.hitTime - b.hitTime));
    },

    async prepareGame(editorMode) {
        document.getElementById('pause-screen').style.display = 'none';
        document.getElementById('editor-menu-screen').style.display = 'none';
        document.getElementById('result-screen').style.display = 'none';
        document.getElementById('detail-editor-ui').style.display = 'none'; // Ensure hidden

        const song = SongLibrary.songs[SongLibrary.selectedIdx];
        if (!song) return;
        if (song.type === 'BUFFER') { audio.audioBuffer = song.buffer; audio.mode = 'BUFFER'; } else { audio.setUseSynth(); }
        this.isEditor = editorMode; this.isRecording = false;
        document.getElementById('song-select-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('play-controls').style.display = editorMode ? 'none' : 'flex';
        document.getElementById('editor-controls').style.display = editorMode ? 'flex' : 'none';
        document.getElementById('rec-instruction').style.display = editorMode ? 'block' : 'none';
        
        document.getElementById('rec-btn').style.display = 'block';
        document.getElementById('editor-pause-btn').style.display = 'none';

        this.score=0; this.combo=0; this.maxCombo=0;
        this.stats={p:0,g:0,m:0}; this.particles=[];
        this.isAP = true; this.isFC = true;
        this.updateUI();
        document.getElementById('combo-val').innerText = ""; 
        document.getElementById('combo-label').style.opacity = 0;
        document.getElementById('combo-box').style.display = 'block'; // Reset visibility

        this.lanes = Array(this.laneCount).fill().map(()=>[]);
        this.state = 'COUNTDOWN'; 

        if (editorMode) {
            document.getElementById('rec-btn').classList.remove('recording');
            this.loadChart(song.chart || []); 
            this.state = 'EDITOR_IDLE'; 
        } else {
            await this.countdown();
            
            if (audio.mode === 'SYNTH') {
                this.lanes = Array(this.laneCount).fill().map(()=>[]);
            } else {
                this.loadChart(song.chart);
            }
            
            this.state = 'PLAYING'; 
            await audio.start(0);
        }
    },
    async countdown() {
        if(this.isCountingDown) return;
        this.isCountingDown = true;
        const o = document.getElementById('countdown-overlay'); 
        const t = document.getElementById('countdown-text');
        o.style.display = 'flex'; 
        
        for(let i=3; i>0; i--) { 
            t.innerText = i; 
            t.className = '';
            void t.offsetWidth;
            t.className = 'count-anim';
            await new Promise(r => setTimeout(r, 1000)); 
        }
        t.innerText = "GO!"; 
        t.className = '';
        void t.offsetWidth;
        t.className = 'go-anim';
        
        await new Promise(r => setTimeout(r, 500)); 
        o.style.display = 'none';
        this.isCountingDown = false;
    },

    // EDITOR
    async startRecording() {
        await this.countdown();
        this.state = 'EDITOR_RECORDING'; this.isRecording = true;
        document.getElementById('rec-btn').style.display = 'none';
        document.getElementById('editor-pause-btn').style.display = 'block';
        if(audio.ctx.state === 'suspended') await audio.ctx.resume();
        await audio.start(0);
    },
    pauseGame() { if(this.state==='PLAYING'){ this.state='PAUSED'; audio.pause(); document.getElementById('pause-screen').style.display='flex'; } },
    pauseEditor() {
        this.state = 'EDITOR_PAUSED'; audio.pause();
        document.getElementById('editor-menu-screen').style.display = 'flex';
    },
    async resumeGame() {
        document.getElementById('pause-screen').style.display='none'; await this.countdown();
        this.state='PLAYING'; await audio.start(audio.pausedAt);
    },
    async resumeEditor() {
        document.getElementById('editor-menu-screen').style.display = 'none';
        await this.countdown();
        this.state = 'EDITOR_RECORDING'; 
        await audio.start(audio.pausedAt); 
    },
    resetEditor() {
        audio.stop(); 
        this.state = 'EDITOR_IDLE'; this.isRecording = false;
        document.getElementById('editor-menu-screen').style.display = 'none';
        document.getElementById('rec-btn').style.display = 'block';
        document.getElementById('editor-pause-btn').style.display = 'none';
        this.prepareGame(true);
    },
    saveAndQuitEditor() {
        this.saveCurrentChart();
        const song = SongLibrary.songs[SongLibrary.selectedIdx];
        SongLibrary.saveChartToStorage(song.chart, song.title);
        this.quitGame();
    },
    saveCurrentChart() {
        const song = SongLibrary.songs[SongLibrary.selectedIdx];
        const chartData = [];
        this.lanes.forEach((laneNotes, lIdx) => {
            laneNotes.forEach(n => { chartData.push({ l: lIdx, t: n.hitTime, k: n.type, d: n.duration }); });
        });
        song.chart = chartData;
    },
    quitGame() {
        audio.stop(); this.state = 'MENU';
        document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
        document.getElementById('hud').style.display = 'none';
        document.getElementById('song-select-screen').style.display = 'flex';
        document.getElementById('detail-editor-ui').style.display = 'none';
    },
    finish(cleared) {
        if(this.state === 'EDITOR_TEST') {
            this.endTestPlay();
            return;
        }
        this.state = 'RESULT'; audio.stop(); document.getElementById('hud').style.display = 'none';
        const rt = document.getElementById('result-title');
        rt.innerText = cleared ? "COMPLETE" : "FAILED"; rt.style.color = cleared ? "#0ff" : "#f00";
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('final-combo').innerText = this.maxCombo;
        let rank = 'F'; if(cleared) { if(this.score>200000) rank='SS'; else if(this.score>150000) rank='S'; else if(this.score>100000) rank='A'; else rank='B'; }
        const rr = document.getElementById('final-rank'); rr.innerText = rank; rr.style.color = (rank==='SS'||rank==='S') ? '#f0f' : (rank==='F'?'#666':'#0ff');
        document.getElementById('result-screen').style.display = 'flex';
    },

    // NEW: Detail Editor Logic
    openDetailEditor() {
        // Capture time before stopping
        let entryTime = 0;
        if (this.state === 'EDITOR_RECORDING' || this.state === 'PLAYING' || audio.isPlaying) {
            entryTime = audio.getCurrentTime();
            audio.stop();
        } else {
            entryTime = audio.pausedAt || this.editorTime || 0;
        }

        // Safety clamp
        if(entryTime < 0) entryTime = 0;
        if(entryTime > audio.getDuration()) entryTime = audio.getDuration();

        this.state = 'EDITOR_DETAIL';
        this.editorTime = entryTime;
        
        // Reset active editor states
        this.isRecording = false;
        document.getElementById('rec-btn').classList.remove('recording');
        document.getElementById('rec-btn').style.display = 'block';
        document.getElementById('editor-pause-btn').style.display = 'none';
        document.getElementById('combo-box').style.display = 'none'; // Hide Combo

        document.getElementById('hud').style.display = 'none';
        document.getElementById('detail-editor-ui').style.display = 'flex';
        document.getElementById('de-seek').max = audio.getDuration();
        this.updateDetailUI();
    },
    closeDetailEditor() {
        document.getElementById('detail-editor-ui').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('combo-box').style.display = 'block'; // Show Combo
        this.state = 'EDITOR_IDLE';
    },
    updateDetailUI() {
        const min = Math.floor(this.editorTime / 60);
        const sec = Math.floor(this.editorTime % 60);
        const ms = Math.floor((this.editorTime % 1) * 1000);
        document.getElementById('de-time').innerText = `${min}:${sec.toString().padStart(2,'0')}.${ms.toString().padStart(3,'0')}`;
        document.getElementById('de-seek').value = this.editorTime;
        
        const modControls = document.getElementById('de-modify-controls');
        const lenControls = document.getElementById('de-len-controls');
        
        if (this.editorTool === 'SELECT' && this.editorSelectedNote) {
            modControls.style.visibility = 'visible';
            if(this.editorSelectedNote.type === 'HOLD') {
                lenControls.style.display = 'flex';
            } else {
                lenControls.style.display = 'none';
            }
        } else {
            modControls.style.visibility = 'hidden';
        }
    },
    startTestPlay() {
        this.saveCurrentChart(); // Sync logic to memory
        this.editorLastPlayTime = this.editorTime;
        document.getElementById('detail-editor-ui').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('editor-controls').style.display = 'none'; // Hide editor buttons during test
        document.getElementById('test-stop-btn').style.display = 'block'; // Show STOP button
        document.getElementById('combo-box').style.display = 'block'; // Show Combo
        
        // NEW: Reset Game Stats for Test Play
        this.score = 0; this.combo = 0; this.maxCombo = 0;
        this.isAP = true; this.isFC = true;
        this.updateUI();
        document.getElementById('combo-val').innerText = ""; 
        document.getElementById('combo-label').style.opacity = 0;
        document.getElementById('judgement').style.opacity = 0;

        // Reset lane hit status for test play
        this.lanes.forEach(l => l.forEach(n => { n.hit = false; n.visible = true; n.holding = false; }));
        
        this.state = 'EDITOR_TEST';
        audio.start(this.editorTime);
    },
    endTestPlay() {
        audio.stop();
        this.state = 'EDITOR_DETAIL';
        this.editorTime = this.editorLastPlayTime;
        document.getElementById('hud').style.display = 'none';
        document.getElementById('detail-editor-ui').style.display = 'flex';
        document.getElementById('editor-controls').style.display = 'flex';
        document.getElementById('test-stop-btn').style.display = 'none'; // Hide STOP button
        document.getElementById('combo-box').style.display = 'none'; // Hide Combo
        
        // Reset visible status for editor view
        this.lanes.forEach(l => l.forEach(n => { n.hit = false; n.visible = true; }));
    },
    handleDetailClick(x, y) {
        // Render coordinates logic:
        const w = this.canvas.width;
        const h = this.canvas.height;
        const lW = w / 8;
        const jY = h * 0.85; // Judgement Line Y
        
        const lane = Math.floor(x / lW);
        if (lane < 0 || lane > 7) return;

        // Calculate time from Y
        // y = jY - (tDiff * speed * zoom)
        // tDiff = (jY - y) / (speed * zoom)
        // tDiff = noteTime - editorTime => noteTime = tDiff + editorTime
        
        const tDiff = (jY - y) / (Settings.speed * this.editorZoom);
        let noteTime = this.editorTime + tDiff;
        
        // Snap Logic
        if (this.editorSnap > 0) {
            const secPerBeat = 60 / audio.bpm;
            const snapInterval = secPerBeat * this.editorSnap * 4; // 1/4 means beat
            noteTime = Math.round(noteTime / snapInterval) * snapInterval;
        }

        if (this.editorTool === 'SELECT') {
            // Find closest note
            let closest = null;
            let minDist = 0.2; // 200ms radius
            
            this.lanes[lane].forEach(n => {
                const dist = Math.abs(n.hitTime - noteTime);
                if(dist < minDist) { minDist = dist; closest = n; }
            });
            this.editorSelectedNote = closest;
            this.updateDetailUI();
            return;
        }

        if (this.editorTool === 'DEL') {
             // Find closest note and remove
            let removeIdx = -1;
            let minDist = 0.1;
            this.lanes[lane].forEach((n, i) => {
                if(Math.abs(n.hitTime - noteTime) < minDist) removeIdx = i;
            });
            if(removeIdx !== -1) this.lanes[lane].splice(removeIdx, 1);
            return;
        }

        if (['TAP', 'FLICK', 'HOLD'].includes(this.editorTool)) {
            // Add note
            const duration = this.editorTool === 'HOLD' ? 0.5 : 0;
            this.lanes[lane].push({ hitTime: noteTime, type: this.editorTool, duration: duration, hit: false, holding: false, visible: true });
            this.lanes[lane].sort((a,b) => a.hitTime - b.hitTime);
        }
    },


    // INPUT HANDLERS
    handleInputStart(lane, x, y, isShift, touchId) {
        if (this.state === 'EDITOR_DETAIL') {
            // Start Scroll Detection
            this.editorIsScrolling = false;
            this.editorScrollStartY = y;
            this.editorScrollStartTime = this.editorTime;
            return;
        }
        if (this.state === 'EDITOR_RECORDING') {
            const now = audio.getCurrentTime();
            this.activeLanes.set(lane, { startTime: now, startX: x, startY: y, isFlick: false, touchId: touchId });
            return;
        }
        if (this.state !== 'PLAYING' && this.state !== 'EDITOR_TEST') return;
        this.activeLanes.set(lane, { startX: x, startY: y, isHolding: true, touchId: touchId });
        const now = audio.getCurrentTime(); const notes = this.lanes[lane];
        for(let i=0; i<notes.length; i++) {
            const n = notes[i];
            if(n.hit || !n.visible) continue;
            const diff = (n.hitTime + Settings.offset) - now;
            if(diff < -0.2) continue;
            if(Math.abs(diff) <= 0.2) {
                if(n.type === 'FLICK') continue;
                if(n.type === 'TAP' || n.type === 'HOLD') {
                    if(n.type === 'TAP') { n.hit = true; n.visible = false; this.processJudge(diff, lane, '#0ff'); }
                    else if (n.type === 'HOLD') { n.holding = true; this.processJudge(diff, lane, '#0f0'); }
                    return;
                }
            }
        }
    },
    handleInputMove(lane, x, y) {
        if (this.state === 'EDITOR_DETAIL') {
             // Scroll Logic
            const dy = y - this.editorScrollStartY;
            if (Math.abs(dy) > 10) this.editorIsScrolling = true;
            
            if (this.editorIsScrolling) {
                const timeShift = dy / (Settings.speed * this.editorZoom);
                this.editorTime = Math.max(0, Math.min(audio.getDuration(), this.editorScrollStartTime + timeShift));
                this.updateDetailUI();
            }
            return;
        }
        if (this.state === 'EDITOR_RECORDING') {
            const data = this.activeLanes.get(lane);
            if(data) {
                const dist = Math.hypot(x - data.startX, y - data.startY);
                if (dist > 30) data.isFlick = true;
            }
            return;
        }
        if (this.state !== 'PLAYING' && this.state !== 'EDITOR_TEST') return;
        const inputData = this.activeLanes.get(lane); if(!inputData) return;
        const dy = y - inputData.startY;
        if(Math.abs(dy) > 20) {
            const now = audio.getCurrentTime(); const notes = this.lanes[lane];
            for(let i=0; i<notes.length; i++) {
                const n = notes[i];
                if(n.hit || !n.visible || n.type !== 'FLICK') continue;
                const diff = (n.hitTime + Settings.offset) - now;
                if(Math.abs(diff) <= 0.2) { n.hit = true; n.visible = false; this.processJudge(diff, lane, '#ff0'); return; }
            }
        }
    },
    handleInputEnd(lane, touchId) {
        if (this.state === 'EDITOR_DETAIL') {
            if (!this.editorIsScrolling) {
                // Handled in listeners directly for simplicity
            }
            return;
        }

        let targetLane = lane;
        if (targetLane === null && touchId !== undefined) {
            for (const [l, data] of this.activeLanes.entries()) {
                if (data.touchId === touchId) { targetLane = l; break; }
            }
        }
        if (targetLane === null || !this.activeLanes.has(targetLane)) return;
        lane = targetLane;

        if (this.state === 'EDITOR_RECORDING') {
            const data = this.activeLanes.get(lane);
            if (data) {
                const now = audio.getCurrentTime();
                const duration = now - data.startTime;
                let type = 'TAP'; let finalDur = 0;
                if (data.isFlick) type = 'FLICK';
                else if (duration > 0.6) { type = 'HOLD'; finalDur = duration; }
                this.lanes[lane].push({ hitTime: data.startTime, type: type, duration: finalDur, hit: false, holding: false, visible: true });
                this.lanes[lane].sort((a,b) => a.hitTime - b.hitTime);
                this.activeLanes.delete(lane);
            }
            return;
        }

        if (this.state !== 'PLAYING' && this.state !== 'EDITOR_TEST') return;
        this.activeLanes.delete(lane);
        const notes = this.lanes[lane];
        for(let i=0; i<notes.length; i++) {
            const n = notes[i];
            if(n.type === 'HOLD' && n.holding && n.visible) {
                n.holding = false; n.visible = false; this.judge('MISS', '#888'); this.stats.m++; this.breakCombo(true);
            }
        }
    },
    processJudge(diff, lane, color) {
        const absD = Math.abs(diff);
        if(absD <= 0.05) { this.judge('PERFECT', color); this.addScore(100); this.stats.p++; this.spawnParticles(lane, color); }
        else if(absD <= 0.12) { 
            this.judge('GOOD', '#fff'); 
            this.addScore(50); 
            this.stats.g++; 
            this.isAP = false; 
            this.spawnParticles(lane, '#fff'); 
        }
        else { this.judge('BAD', '#f00'); this.breakCombo(false); }
    },
    judge(txt, col) {
        const el = document.getElementById('judgement');
        el.innerText = txt; el.style.color = col; el.style.opacity=1; el.style.transform = 'translate(-50%,-50%) scale(1.5)';
        requestAnimationFrame(()=>{ el.style.transition='0.1s'; el.style.transform='translate(-50%,-50%) scale(1)'; });
        clearTimeout(this.jTimer); this.jTimer=setTimeout(()=>{el.style.opacity=0;},500);
    },
    addScore(v) {
        this.score += Math.floor(v * (1 + this.combo*0.02)); this.combo++;
        if(this.combo > this.maxCombo) this.maxCombo=this.combo;
        this.updateUI();
        const cb = document.getElementById('combo-label'); cb.style.opacity = this.combo > 2 ? 1 : 0;
        const cv = document.getElementById('combo-val'); cv.innerText = this.combo > 2 ? this.combo : "";
        cv.parentElement.style.transform = 'translateX(-50%) scale(1.2)';
        setTimeout(()=>cv.parentElement.style.transform='translateX(-50%) scale(1)', 50);
        
        cv.className = 'combo-val';
        if (this.isAP) cv.classList.add('combo-ap');
        else if (this.isFC) cv.classList.add('combo-fc');
        else cv.classList.add('combo-norm');
    },
    breakCombo(isMiss) {
        if (this.isEditor) return;
        this.combo = 0; 
        this.isAP = false; this.isFC = false;
        this.updateUI();
        document.getElementById('combo-label').style.opacity=0; document.getElementById('combo-val').innerText="";
        this.canvas.style.transform = `translate(${Math.random()*4-2}px,${Math.random()*4-2}px)`;
        setTimeout(()=>this.canvas.style.transform='none',50);
    },
    updateUI() {
        document.getElementById('score').innerText = this.score;
    },
    spawnParticles(lane, col) {
        const w = this.canvas.width/8; const x = lane*w + w/2; const y = this.canvas.height*0.85;
        for(let i=0; i<8; i++) { this.particles.push({ x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10-5, life:1, col:col, size:Math.random()*5+2 }); }
    },

    loop(timestamp) {
        requestAnimationFrame((ts) => this.loop(ts));
        if (!this.lastTime) this.lastTime = timestamp;
        const interval = 1000 / 60;
        const deltaTime = timestamp - this.lastTime;
        if (deltaTime > interval) {
            this.lastTime = timestamp - (deltaTime % interval);
            if(this.state === 'PAUSED' || this.state === 'MENU' || this.state === 'RESULT' || this.state === 'EDITOR_PAUSED') return;
            
            const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height;
            const now = (this.state === 'EDITOR_DETAIL') ? this.editorTime : audio.getCurrentTime();
            
            if ((this.state === 'PLAYING' || this.state === 'EDITOR_TEST') && now > audio.getDuration() + 1.0) { this.finish(true); }
            if (this.state === 'EDITOR_RECORDING' && now > audio.getDuration() + 1.0) { this.pauseEditor(); }

            ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
            if (this.state === 'EDITOR_RECORDING') { ctx.fillStyle = 'rgba(20,0,0,0.5)'; ctx.fillRect(0,0,w,h); }
            
            // Detail Editor Background
            if (this.state === 'EDITOR_DETAIL') {
                ctx.fillStyle = '#051015'; ctx.fillRect(0,0,w,h);
                // Draw Grid (every second)
                const speed = Settings.speed * this.editorZoom;
                const jY = h * 0.85;
                const startTime = this.editorTime - (jY / speed); // Time at top of screen
                const endTime = this.editorTime + ((h - jY) / speed); // Time at bottom (approx)
                
                // Draw Beats (simplified)
                const secPerBeat = 60 / audio.bpm;
                const startBeat = Math.floor((this.editorTime - 2.0) / secPerBeat);
                const endBeat = startBeat + 20;

                ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
                for(let b = startBeat; b <= endBeat; b++) {
                    if(b<0) continue;
                    const bTime = b * secPerBeat;
                    const bY = jY - ((bTime - this.editorTime) * speed);
                    ctx.beginPath(); ctx.moveTo(0, bY); ctx.lineTo(w, bY); ctx.stroke();
                }
            }

            // State specific render guard
            if (this.state === 'COUNTDOWN') return;

            const prog = Math.min(100, (now/audio.getDuration())*100);
            if(this.state !== 'EDITOR_DETAIL') document.getElementById('time-bar').style.width = (100-prog)+'%';
            
            const lW = w / 8; const jY = h * 0.85;
            ctx.lineWidth = 1;
            for(let i=0; i<=8; i++) { ctx.strokeStyle = i===4 ? '#555' : '#222'; ctx.beginPath(); ctx.moveTo(i*lW,0); ctx.lineTo(i*lW,h); ctx.stroke(); }
            
            // Draw Judgement Line
            ctx.strokeStyle = '#0ff'; ctx.lineWidth=4; ctx.shadowBlur=10; ctx.shadowColor='#0ff';
            ctx.beginPath(); ctx.moveTo(0,jY); ctx.lineTo(w,jY); ctx.stroke(); ctx.shadowBlur=0;

            this.activeLanes.forEach((v, k) => {
                const g = ctx.createLinearGradient(0,jY,0,0); g.addColorStop(0, 'rgba(0,255,255,0.3)'); g.addColorStop(1,'transparent');
                ctx.fillStyle=g; ctx.fillRect(k*lW,0,lW,jY);

                if (this.state === 'EDITOR_RECORDING') {
                    const duration = now - v.startTime;
                    const dropDist = duration * Settings.speed;
                    const headY = jY + dropDist;
                    const tailY = jY;
                    const nx = k * lW + 4;
                    const nw = lW - 8;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.fillRect(nx, tailY, nw, headY - tailY);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(nx, headY - 8, nw, 16);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(nx + 2, headY - 6, nw - 4, 12);
                }
            });

            this.lanes.forEach((notes, lIdx) => {
                for(let i=notes.length-1; i>=0; i--) {
                    const n = notes[i];
                    // EDITOR ZOOM SUPPORT
                    const speed = (this.state === 'EDITOR_DETAIL') ? (Settings.speed * this.editorZoom) : Settings.speed;
                    
                    const tDiff = (n.hitTime + Settings.offset) - now;
                    const y = jY - (tDiff * speed);

                    if(n.type === 'HOLD' && n.holding && this.state !== 'EDITOR_DETAIL') {
                        const tailDiff = (n.hitTime + n.duration + Settings.offset) - now;
                        if(tailDiff <= 0) { n.holding = false; n.visible = false; n.hit = true; this.judge('PERFECT', '#0f0'); this.addScore(200); this.spawnParticles(lIdx, '#0f0'); }
                    }
                    if (!this.isEditor && !n.hit && tDiff < -0.2 && n.visible && !n.holding && this.state !== 'EDITOR_TEST') {
                        n.visible = false; this.judge('MISS', '#888'); this.stats.m++; this.breakCombo(true);
                    }
                    if (y > h + 50 && !n.holding && this.state !== 'EDITOR_DETAIL') { 
                        if (!this.isEditor && n.visible && !n.hit && this.state !== 'EDITOR_TEST') { this.judge('MISS', '#888'); this.stats.m++; this.breakCombo(true); }
                        if (!this.isEditor && this.state !== 'EDITOR_TEST') notes.splice(i,1); 
                        if (this.state !== 'EDITOR_DETAIL') continue; 
                    }
                    
                    // Draw if on screen
                    if (n.visible && (y > -300 || n.holding || this.state === 'EDITOR_DETAIL')) {
                        const nx = lIdx*lW+4; const nw = lW-8;
                        
                        // Highlight selected in editor
                        if (this.state === 'EDITOR_DETAIL' && this.editorSelectedNote === n) {
                            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                            ctx.fillRect(nx-2, y-10, nw+4, 20);
                        }

                        if(n.type === 'HOLD') {
                            const tailY = jY - ((tDiff + n.duration) * speed); 
                            const headY = n.holding ? jY : y;
                            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; ctx.fillRect(nx, tailY, nw, Math.max(0, headY - tailY));
                        }
                        // Always draw notes in Editor Detail even if "past" line
                        if(y > -50 || n.holding || this.state === 'EDITOR_DETAIL') {
                            const drawY = n.holding ? jY : y;
                            let col = n.type==='FLICK'?'#ff0':(n.type==='HOLD'?'#0f0':'#0ff');
                            if(this.state==='EDITOR_DETAIL' && n.type==='HOLD') col='#0a0'; // Darker green for hold start in editor

                            ctx.fillStyle = '#fff'; ctx.shadowBlur = 10; ctx.shadowColor = col;
                            ctx.fillRect(nx, drawY-8, nw, 16); ctx.fillStyle = col; ctx.fillRect(nx+2, drawY-6, nw-4, 12);
                            if(n.type === 'FLICK') {
                                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(nx + nw/2, drawY - 4);
                                ctx.lineTo(nx + nw/2 - 5, drawY + 4); ctx.lineTo(nx + nw/2 + 5, drawY + 4); ctx.fill();
                            }
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            });
            for(let i=this.particles.length-1; i>=0; i--) {
                const p = this.particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.05;
                if(p.life<=0) { this.particles.splice(i,1); continue; }
                ctx.globalAlpha = p.life; ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1;
            }
        }
    },

    setupInputs() {
        // UI Binds
        document.getElementById('play-song-btn').addEventListener('click', () => this.prepareGame(false));
        document.getElementById('editor-btn').addEventListener('click', () => this.prepareGame(true));
        document.getElementById('pause-btn').addEventListener('click', () => { if(this.state==='PLAYING'){ this.state='PAUSED'; audio.pause(); document.getElementById('pause-screen').style.display='flex'; }});
        document.getElementById('resume-btn').addEventListener('click', async () => { document.getElementById('pause-screen').style.display='none'; await this.countdown(); this.state='PLAYING'; audio.start(audio.pausedAt); });
        document.getElementById('retry-btn').addEventListener('click', () => this.prepareGame(this.isEditor));
        document.getElementById('res-retry-btn').addEventListener('click', () => this.prepareGame(this.isEditor));
        document.getElementById('quit-btn').addEventListener('click', () => this.quitGame());
        document.getElementById('res-quit-btn').addEventListener('click', () => this.quitGame());
        
        document.getElementById('rec-btn').addEventListener('click', () => this.startRecording());
        document.getElementById('detail-btn').addEventListener('click', () => this.openDetailEditor()); // NEW
        
        document.getElementById('editor-pause-btn').addEventListener('click', () => this.pauseEditor());
        
        document.getElementById('editor-resume-btn').addEventListener('click', () => this.resumeEditor());
        document.getElementById('editor-reset-btn').addEventListener('click', () => this.resetEditor());
        document.getElementById('editor-save-btn').addEventListener('click', () => this.saveAndQuitEditor());
        
        // NEW: Detail Save
        document.getElementById('de-save-btn').addEventListener('click', () => this.saveAndQuitEditor());
        
        // NEW: Export Zip
        document.getElementById('editor-zip-btn').addEventListener('click', () => SongLibrary.exportZipPackage(SongLibrary.selectedIdx));
        
        // NEW: Detail Zip Export
        document.getElementById('de-zip-btn').addEventListener('click', () => SongLibrary.exportZipPackage(SongLibrary.selectedIdx));
        
        // NEW: Test Play Stop Button
        document.getElementById('test-stop-btn').addEventListener('click', () => this.endTestPlay());

        document.getElementById('global-settings-btn').addEventListener('click', () => { Settings.load(); document.getElementById('settings-screen').style.display='flex'; });
        document.getElementById('settings-close-btn').addEventListener('click', () => { Settings.save(); document.getElementById('settings-screen').style.display='none'; });

        // Detail Editor Inputs
        document.getElementById('de-exit-btn').addEventListener('click', () => this.closeDetailEditor());
        document.getElementById('de-seek').addEventListener('input', (e) => { this.editorTime = parseFloat(e.target.value); this.updateDetailUI(); });
        document.getElementById('de-zoom').addEventListener('input', (e) => { this.editorZoom = parseFloat(e.target.value); });
        document.getElementById('de-test-btn').addEventListener('click', () => this.startTestPlay());

        const tools = ['SELECT', 'TAP', 'FLICK', 'HOLD', 'DEL'];
        tools.forEach(t => {
            document.getElementById('tool-'+t.toLowerCase()).addEventListener('click', (e) => {
                this.editorTool = t;
                tools.forEach(x => document.getElementById('tool-'+x.toLowerCase()).classList.remove('active'));
                e.target.classList.add('active');
                this.updateDetailUI();
            });
        });

        document.getElementById('tool-snap').addEventListener('click', (e) => {
            const snaps = [0, 0.25]; // Off, 1/4 (Beat)
            const labels = ["OFF", "1/4"];
            let idx = snaps.indexOf(this.editorSnap);
            idx = (idx + 1) % snaps.length;
            this.editorSnap = snaps[idx];
            e.target.innerText = labels[idx];
        });

        document.getElementById('mod-minus').addEventListener('click', () => {
            if(this.editorSelectedNote) { this.editorSelectedNote.hitTime -= 0.01; this.updateDetailUI(); }
        });
        document.getElementById('mod-plus').addEventListener('click', () => {
            if(this.editorSelectedNote) { this.editorSelectedNote.hitTime += 0.01; this.updateDetailUI(); }
        });
        // NEW: Length modification
        document.getElementById('mod-len-minus').addEventListener('click', () => {
            if(this.editorSelectedNote && this.editorSelectedNote.type === 'HOLD') { 
                this.editorSelectedNote.duration = Math.max(0.1, this.editorSelectedNote.duration - 0.05);
                this.updateDetailUI(); 
            }
        });
        document.getElementById('mod-len-plus').addEventListener('click', () => {
            if(this.editorSelectedNote && this.editorSelectedNote.type === 'HOLD') { 
                this.editorSelectedNote.duration += 0.05;
                this.updateDetailUI(); 
            }
        });

        // File Loading
        document.getElementById('audio-upload').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const arrayBuff = ev.target.result;
                    audio.ctx.decodeAudioData(arrayBuff).then(buff => {
                        SongLibrary.addSong(f.name, buff);
                    });
                };
                reader.readAsArrayBuffer(f);
            }
        });
        // Zip Import
        document.getElementById('zip-upload').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f && window.JSZip) {
                JSZip.loadAsync(f).then(function(zip) {
                    let chartFile = zip.file("chart.json");
                    let audioFile = null;
                    zip.forEach((path, file) => {
                        if(path.match(/\.(mp3|wav|ogg)$/i)) audioFile = file;
                    });
                    
                    if(chartFile && audioFile) {
                        Promise.all([
                            chartFile.async("string"),
                            audioFile.async("arraybuffer"),
                            audioFile.async("blob")
                        ]).then(values => {
                            const chartJson = JSON.parse(values[0]);
                            const audioBuff = values[1];
                            const audioBlob = values[2];
                            audioBlob.name = audioFile.name; // Keep name for extension
                            
                            audio.ctx.decodeAudioData(audioBuff).then(buff => {
                                const newId = Date.now();
                                const title = f.name.replace('.zip','');
                                SongLibrary.songs.push({ 
                                    id: newId, 
                                    title: title, 
                                    type: 'BUFFER', 
                                    buffer: buff, 
                                    chart: chartJson,
                                    originalBlob: audioBlob 
                                });
                                // Also save chart to library
                                SongLibrary.saveChartToStorage(chartJson, title);
                                
                                SongLibrary.selectedIdx = SongLibrary.songs.length - 1;
                                SongLibrary.renderList();
                                alert("Package Imported & Chart Saved!");
                            });
                        });
                    } else { alert("Invalid Zip: Must contain chart.json and audio file"); }
                });
            }
        });
        
        document.getElementById('chart-upload').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const chart = JSON.parse(ev.target.result);
                        const title = f.name.replace(/\.json$/i, "");
                        SongLibrary.saveChartToStorage(chart, title); // Save to library
                        alert("Chart Imported to Library!");
                    } catch(err) { alert("Invalid JSON"); }
                };
                reader.readAsText(f);
            }
        });

        // Touch
        const lW = () => this.canvas.width/8;
        const touchHandler = (e, type) => {
            if(this.state==='MENU' || this.state==='PAUSED' || this.state==='EDITOR_PAUSED') return;
            if(e.target === this.canvas) e.preventDefault();
            
            const ts = e.changedTouches;
            for(let i=0; i<ts.length; i++) {
                const t = ts[i];
                const width = lW();
                let l = Math.floor(t.clientX / width);
                
                // [FIX] Lane Correction Logic for simultaneous/adjacent touches
                if (type === 'start' && (this.state === 'PLAYING' || this.state === 'EDITOR_TEST' || this.state === 'EDITOR_RECORDING')) {
                    if (this.activeLanes.has(l)) {
                        const laneX = t.clientX % width;
                        const borderThreshold = width * 0.35; 
                        if (laneX < borderThreshold && l > 0 && !this.activeLanes.has(l - 1)) {
                            l = l - 1;
                        } 
                        else if (laneX > (width - borderThreshold) && l < 7 && !this.activeLanes.has(l + 1)) {
                            l = l + 1;
                        }
                    }
                }

                if(type==='start') this.handleInputStart(l, t.clientX, t.clientY, false, t.identifier);
                else if(type==='move') {
                    // â˜… SLIDE TOUCH LOGIC â˜…
                    if (this.state === 'PLAYING' || this.state === 'EDITOR_TEST') {
                        let prevLane = -1;
                        for (const [al, data] of this.activeLanes.entries()) {
                            if (data.touchId === t.identifier) {
                                prevLane = al;
                                break;
                            }
                        }

                        if (prevLane !== -1 && prevLane !== l) {
                            // Lane Changed!
                            // 1. Un-hold notes in previous lane (treat as released/moved away)
                            const oldNotes = this.lanes[prevLane];
                            if (oldNotes) {
                                oldNotes.forEach(n => { if (n.holding) n.holding = false; });
                            }
                            this.activeLanes.delete(prevLane); 

                            // 2. Trigger input in new lane
                            if (l >= 0 && l < 8) {
                                this.handleInputStart(l, t.clientX, t.clientY, false, t.identifier);
                            }
                        }
                    }

                    this.handleInputMove(l, t.clientX, t.clientY);
                }
                else if(type==='end') {
                    if (this.state === 'EDITOR_DETAIL' && !this.editorIsScrolling) {
                        this.handleDetailClick(t.clientX, t.clientY);
                    }
                    this.handleInputEnd(null, t.identifier);
                }
            }
        };
        this.canvas.addEventListener('touchstart', e => touchHandler(e, 'start'), {passive:false});
        this.canvas.addEventListener('touchmove', e => touchHandler(e, 'move'), {passive:false});
        this.canvas.addEventListener('touchend', e => touchHandler(e, 'end'));
        
        // Mouse/Key
        const keys = {'KeyS':0,'KeyD':1,'KeyF':2,'KeyG':3,'KeyH':4,'KeyJ':5,'KeyK':6,'KeyL':7};
        window.addEventListener('keydown', e => {
            if((this.state==='PLAYING' || this.state==='EDITOR_RECORDING' || this.state==='EDITOR_TEST') && keys.hasOwnProperty(e.code) && !e.repeat) {
                this.handleInputStart(keys[e.code], 0, 0, e.shiftKey, 'key-' + e.code);
            }
            if(e.code==='Escape') {
                if(this.state==='PLAYING' || this.state==='EDITOR_TEST') { audio.stop(); this.state='PAUSED'; document.getElementById('pause-screen').style.display='flex'; }
            }
        });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) this.handleInputEnd(null, 'key-' + e.code); });
        
        this.canvas.addEventListener('mousedown', e => {
            if(this.state!=='PLAYING' && this.state!=='EDITOR_RECORDING' && this.state !== 'EDITOR_DETAIL' && this.state !== 'EDITOR_TEST') return;
            const l = Math.floor(e.clientX / lW());
            this.handleInputStart(l, e.clientX, e.clientY, false, 'mouse');
        });
        this.canvas.addEventListener('mousemove', e => {
            if(this.state==='EDITOR_DETAIL') this.handleInputMove(0, e.clientX, e.clientY);
        });
        this.canvas.addEventListener('mouseup', e => {
             if (this.state === 'EDITOR_DETAIL' && !this.editorIsScrolling) {
                this.handleDetailClick(e.clientX, e.clientY);
            }
            this.handleInputEnd(null, 'mouse');
        });
    }
};

game.init();
</script>
</body>
</html>


